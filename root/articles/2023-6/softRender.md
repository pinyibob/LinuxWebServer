# 软渲染管线制作原理

一般opengl可编程的部分在于顶点，几何，片段着色器，很多通用计算细节在gpu上运行而对人隐藏，如果想稍微深入学习管线的工作原理，在cpu层面通过drawPixel的接口，实现一个软件光栅化程序是个不错的想法；笔者由于时间受限，阅读一份代码而替代，并整理出以下笔记及涉及到的主要过程和概念；

使用到的代码链接为 [github_link](https://github.com/SilverClawko/SoftRender)

作者系列文章教学链接为 [知乎_link](https://zhuanlan.zhihu.com/p/95621444)

## 素材准备阶段
通常管线绘制的是三角形和四边形，且通常对应一张贴图纹理，也就是需要顶点坐标集和对应纹理；
1. 可以通过自己设计点构造VBO，VEO得到顶点坐标集；
2. 可通过三方库例如stbi库，直接导入纹理，并和对应贴图顶点映射；
3. 自己解析obj文件结构，分析得到顶点坐标，法向量，纹理数据，纹理坐标等；
在代码中，涉及到的类有Vertex.h, Model.h, Mesh.h, Texture 采样类（liner， near法）

名词解释：
以unity规范为例，一个模型由多个对象组成，每个对象拥有网格和材质；
**网格(mesh)**：多边形的绘制信息，包括顶点位置、顶点法向、顶点纹理坐标，顶点索引。
**材质(material)**：漫反射光颜色、镜面反射光颜色、镜面反射光泽度等光照计算信息，还有纹理（Texture）数据和记录如何使用纹理的贴图（Map）信息

## 顶点处理阶段
主要是顶点着色器的编写
主要功能是将待绘制顶点的模型坐标，转化到相机视图坐标； 这里需要一个相机类camera.h进行自由视角变化和鼠标操作；
在代码中可以看到，是以***三角形***为基础，遍历绘制核心图像，每个三角形的绘制都需要走一整个管线渲染流程；此处的代码可以使用tbb库并发进行，模拟gpu环境，帧率会有大幅度提升；
[!管线渲染入口](../../picture/)

顶点处理：
[!vertex_dealing](../../picture/)

MVP矩阵处理后，得到了点坐标都在[-w,w]区间内的数据，我们对x,y,z坐标都除以w（w是变换之前的z的相反数），最终得到了坐标都在[-1,1]之间的标准设备坐标（NDC），这个过程被称作**透视除法**

## 几何处理阶段
主要包含
1. 视锥裁剪：将视锥外的图形的三角形不考虑绘制; 通常采用aabb简化计算；
2. 视口裁剪：落在屏幕显示区域外的三角形不考虑绘制； 通常使用逐边裁剪法（Sutherland–Hodgman）；
3. 背面剔除：模型背面的三角形不考虑绘制； 利用三角形的渲染顺序，判断相机方向和当前像素点插值法向量是否为锐角，进行排除；
4. 遮挡剔除；

## 光栅化阶段和片段着色器
对每个确定需要绘制的像素点，使用片段着色器考虑纹理，光照，depth buffer等条件，获取最终颜色，并填入显示缓冲内存；

### 该过程中的核心点

光栅化算法：
1. Bresenham是常用绘制**线条**方法： 令每次最大变化方向的坐标步进一个象素，同时另一个方向的坐标依据误差判别式的符号来决定是否也要步进一个象素。
2. 绘制**三角形**一般使用**扫描线填充**方法： 从三角形最上面的点开始往下逐步画横线，两个交点之间的区域就是覆盖的区域。
3. depth buffer，将绘制点插值计算深度，选用深度最浅的渲染颜色结果；

标准光照模型（phong）：
三部分：
1. 环境光
2. 漫反射
3. 镜面反射

光照类型：
1. 平行光： 反射的计算 2n * cos(n,l) - l = r
2. 点光： 点光源的光照亮度随着距离平方反比衰减，由常数项、一次项、二次项三个参数控制；f = 1.0/ (kc _ kl * d + kq * d^2)
3. 聚光灯： 像素到光源位置的方向与光源正向夹角被称为切光角，切光角在设定范围内的像素，按照点光源的方式计算光照。切光角之外的像素不会被照亮。

## 一下轮准备阶段
1. 将渲染结束的buffer切换至显示，并将当前渲染缓存指针，指向替换下来的buffer；
2. 释放帧完成信号, 提示ui刷新绘制，并开始新一轮绘制的前置操作;